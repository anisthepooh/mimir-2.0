{"version":3,"file":"stega.browser.cjs","sources":["../src/stega/config.ts","../src/csm/getPublishedId.ts","../src/csm/studioPath.ts","../src/csm/jsonPath.ts","../src/csm/createEditUrl.ts","../src/csm/resolveMapping.ts","../src/csm/resolveEditInfo.ts","../src/csm/isArray.ts","../src/csm/isRecord.ts","../src/csm/walkMap.ts","../src/stega/encodeIntoResult.ts","../src/stega/filterDefault.ts","../src/stega/stegaEncodeSourceMap.ts","../src/stega/SanityStegaClient.ts","../src/stega/vercelStegaCleanAll.ts","../src/stega/index.browser.ts"],"sourcesContent":["import type {ClientConfig} from '../types'\nimport type {ClientStegaConfig, InitializedStegaConfig, StegaConfig} from './types'\n\nexport const defaultStegaConfig: StegaConfig = {\n  enabled: false,\n  filter: (props) => props.filterDefault(props),\n  vercelStegaCombineSkip: 'auto',\n}\n\nexport function splitConfig(config: ClientStegaConfig): {\n  clientConfig: ClientConfig\n  stegaConfig: StegaConfig\n} {\n  const {stega = {}, ...clientConfig} = config\n  return {clientConfig, stegaConfig: stega}\n}\n\nexport const initStegaConfig = (\n  config: Partial<StegaConfig>,\n  prevConfig: Partial<StegaConfig>,\n): InitializedStegaConfig => {\n  const specifiedConfig = Object.assign({} as StegaConfig, prevConfig, config)\n  const newConfig = Object.assign({} as InitializedStegaConfig, defaultStegaConfig, specifiedConfig)\n\n  if ('encodeSourceMap' in newConfig) {\n    throw new Error(\n      `It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client/stega'. Did you mean 'enabled'?`,\n    )\n  }\n\n  if ('encodeSourceMapAtPath' in newConfig) {\n    throw new Error(\n      `It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client/stega'. Did you mean 'filter'?`,\n    )\n  }\n\n  if (typeof newConfig.enabled !== 'boolean') {\n    throw new Error(`config.enabled must be a boolean, received ${newConfig.enabled}`)\n  }\n\n  if (newConfig.enabled && newConfig.studioUrl === undefined) {\n    throw new Error(`config.studioUrl must be defined when config.enabled is true`)\n  }\n\n  if (\n    newConfig.enabled &&\n    typeof newConfig.studioUrl !== 'string' &&\n    typeof newConfig.studioUrl !== 'function'\n  ) {\n    throw new Error(\n      `config.studioUrl must be a string or a function, received ${newConfig.studioUrl}`,\n    )\n  }\n\n  return newConfig\n}\n","const DRAFTS_PREFIX = 'drafts.'\n\n/** @internal */\nexport function getPublishedId(id: string): string {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length)\n  }\n\n  return id\n}\n","/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n","import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n","import {getPublishedId} from './getPublishedId'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    projectId,\n    dataset,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!projectId) {\n    throw new Error('projectId is required')\n  }\n  if (!dataset) {\n    throw new Error('dataset is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  // eslint-disable-next-line no-warning-comments\n  // @TODO allow passing draft prefixed IDs, to better open the right perspective mode\n  const id = getPublishedId(_id)\n  const stringifiedPath = studioPath.toString(jsonPathToStudioPath(path))\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    projectId,\n    dataset,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  if (tool) {\n    segments.push(tool)\n  }\n  const routerParams = [`id=${id}`, `type=${type}`, `path=${encodeURIComponent(stringifiedPath)}`]\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n","import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n","import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type, _dataset = options.projectId, _projectId = options.dataset} = sourceDoc\n    return {\n      baseUrl,\n      projectId: _projectId,\n      dataset: _dataset,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n","/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n","import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n","import {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport type {ContentSourceMap} from '../csm/types'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n","import type {FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath}) => {\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && endPath.startsWith('_')) {\n    return false\n  }\n\n  /**\n   * Best effort infer Portable Text paths that should not be encoded.\n   * Nothing is for certain, and the below implementation may cause paths that aren't Portable Text and otherwise be safe to encode to be skipped.\n   * However, that's ok as userland can always opt-in with the `encodeSourceMapAtPath` option and mark known safe paths as such, which will override this heuristic.\n   */\n  // If the path ends in marks[number] it's likely a PortableTextSpan: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#LL154C16-L154C16\n  if (typeof endPath === 'number' && sourcePath.at(-2) === 'marks') {\n    return false\n  }\n  // Or if it's [number].markDefs[number].href it's likely a PortableTextLink: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L163\n  if (\n    endPath === 'href' &&\n    typeof sourcePath.at(-2) === 'number' &&\n    sourcePath.at(-3) === 'markDefs'\n  ) {\n    return false\n  }\n  // Otherwise we have to deal with special properties of PortableTextBlock, and we can't confidently know if it's actually a `_type: 'block'` array item or not.\n  // All we know is that if it is indeed a block, and we encode the strings on these keys it'll for sure break the PortableText rendering and thus we skip encoding.\n  // https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L48-L58\n  if (endPath === 'style' || endPath === 'listItem') {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'slug',\n  'status',\n  'tag',\n  'theme',\n  'template',\n  'type',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n","import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {ContentSourceMap, ContentSourceMapParsedPath, InitializedStegaConfig} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n  clientConfig: {projectId: string | undefined; dataset: string | undefined},\n): Result {\n  const {filter, vercelStegaCombineSkip, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client/stega]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const {projectId, dataset} = clientConfig\n  if (!projectId) {\n    throw new Error('Missing projectId')\n  }\n  if (!dataset) {\n    throw new Error('Missing dataset')\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {\n        _id: id,\n        _type: type,\n        _dataset = clientConfig.projectId,\n        _projectId = clientConfig.dataset,\n      } = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            projectId: _projectId!,\n            dataset: _dataset!,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n          }),\n        },\n        vercelStegaCombineSkip,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.(\n        '[@sanity/client/stega]: Encoding source map into result',\n      )\n      logger.log?.(\n        `[@sanity/client/stega]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client/stega]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client/stega]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n","import {Observable} from 'rxjs'\nimport {map} from 'rxjs/operators'\n\nimport {defaultConfig} from '../config'\nimport {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {\n  Any,\n  ClientConfig,\n  FilteredResponseQueryOptions,\n  HttpRequest,\n  QueryParams,\n  RawQueryResponse,\n  UnfilteredResponseQueryOptions,\n} from '../types'\nimport {defaultStegaConfig, initStegaConfig, splitConfig} from './config'\nimport {stegaEncodeSourceMap} from './stegaEncodeSourceMap'\nimport {ClientStegaConfig, InitializedClientStegaConfig, InitializedStegaConfig} from './types'\n\n/** @public */\nexport class ObservableSanityStegaClient extends ObservableSanityClient {\n  /**\n   * Private properties\n   */\n  #httpRequest: HttpRequest\n  private stegaConfig: InitializedStegaConfig\n\n  constructor(httpRequest: HttpRequest, config: ClientStegaConfig = defaultConfig) {\n    const {clientConfig, stegaConfig} = splitConfig(config)\n    super(httpRequest, clientConfig)\n\n    this.#httpRequest = httpRequest\n    this.stegaConfig = initStegaConfig(stegaConfig, defaultStegaConfig)\n  }\n\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone(): ObservableSanityStegaClient {\n    return new ObservableSanityStegaClient(this.#httpRequest, this.config())\n  }\n\n  /**\n   * Returns the current client configuration\n   */\n  config(): InitializedClientStegaConfig\n  /**\n   * Reconfigure the client. Note that this _mutates_ the current client.\n   */\n  config(newConfig?: Partial<ClientStegaConfig>): this\n  config(newConfig?: Partial<ClientStegaConfig>): ClientStegaConfig | this {\n    if (newConfig === undefined) {\n      return {...super.config(), stega: {...this.stegaConfig}}\n    }\n\n    super.config(newConfig)\n\n    const {stegaConfig} = splitConfig(newConfig)\n\n    this.stegaConfig = initStegaConfig(stegaConfig, this.stegaConfig || {})\n    return this\n  }\n\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig?: Partial<ClientConfig>): ObservableSanityStegaClient {\n    return new ObservableSanityStegaClient(this.#httpRequest, {...this.config(), ...newConfig})\n  }\n\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   */\n  fetch<R = Any>(query: string): Observable<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Query parameters\n   */\n  fetch<R = Any, Q = QueryParams>(query: string, params: Q): Observable<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: FilteredResponseQueryOptions,\n  ): Observable<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: UnfilteredResponseQueryOptions,\n  ): Observable<RawQueryResponse<R>>\n  fetch<R, Q extends QueryParams>(\n    query: string,\n    params?: Q,\n    options: FilteredResponseQueryOptions | UnfilteredResponseQueryOptions = {},\n  ): Observable<RawQueryResponse<R> | R> {\n    if (!this.stegaConfig.enabled) {\n      return super.fetch<R, Q>(query, params, options as Any)\n    }\n    const {filterResponse: originalFilterResponse = true} = options\n    return super\n      .fetch<R, Q>(\n        query,\n        params,\n        Object.assign({}, options as Any, {\n          filterResponse: false,\n          resultSourceMap: 'withKeyArraySelector',\n        }),\n      )\n      .pipe(\n        map((res: Any) => {\n          const {result: _result, resultSourceMap} = res as RawQueryResponse<R>\n          const {projectId, dataset} = this.config()\n          const result = stegaEncodeSourceMap(_result, resultSourceMap, this.stegaConfig, {\n            projectId,\n            dataset,\n          })\n          return originalFilterResponse ? result : {...res, result}\n        }),\n      )\n  }\n}\n\n/** @public */\nexport class SanityStegaClient extends SanityClient {\n  /**\n   * Observable version of the Sanity client, with the same configuration as the promise-based one\n   */\n  observable: ObservableSanityStegaClient\n\n  /**\n   * Private properties\n   */\n  #httpRequest: HttpRequest\n  private stegaConfig: InitializedStegaConfig\n\n  constructor(httpRequest: HttpRequest, config: ClientStegaConfig = defaultConfig) {\n    const {clientConfig, stegaConfig} = splitConfig(config)\n    super(httpRequest, clientConfig)\n\n    this.#httpRequest = httpRequest\n    this.stegaConfig = initStegaConfig(stegaConfig, defaultStegaConfig)\n\n    this.observable = new ObservableSanityStegaClient(httpRequest, config)\n  }\n\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone(): SanityStegaClient {\n    return new SanityStegaClient(this.#httpRequest, this.config())\n  }\n\n  /**\n   * Returns the current client configuration\n   */\n  config(): InitializedClientStegaConfig\n  /**\n   * Reconfigure the client. Note that this _mutates_ the current client.\n   */\n  config(newConfig?: Partial<ClientStegaConfig>): this\n  config(newConfig?: Partial<ClientStegaConfig>): ClientStegaConfig | this {\n    if (newConfig === undefined) {\n      return {...super.config(), stega: {...this.stegaConfig}}\n    }\n\n    super.config(newConfig)\n\n    const {stegaConfig} = splitConfig(newConfig)\n\n    this.stegaConfig = initStegaConfig(stegaConfig, {...(this.stegaConfig || {})})\n    return this\n  }\n\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig?: Partial<ClientStegaConfig>): SanityStegaClient {\n    return new SanityStegaClient(this.#httpRequest, {...this.config(), ...newConfig})\n  }\n\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   */\n  fetch<R = Any>(query: string): Promise<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Optional query parameters\n   */\n  fetch<R = Any, Q = QueryParams>(query: string, params: Q): Promise<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Optional query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: FilteredResponseQueryOptions,\n  ): Promise<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Optional query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: UnfilteredResponseQueryOptions,\n  ): Promise<RawQueryResponse<R>>\n  fetch<R, Q extends QueryParams>(\n    query: string,\n    params?: Q,\n    options: FilteredResponseQueryOptions | UnfilteredResponseQueryOptions = {},\n  ): Promise<RawQueryResponse<R> | R> {\n    if (!this.stegaConfig.enabled) {\n      return super.fetch<R, Q>(query, params, options as Any)\n    }\n    const {filterResponse: originalFilterResponse = true} = options\n    return super\n      .fetch<R, Q>(\n        query,\n        params,\n        Object.assign({}, options as Any, {\n          filterResponse: false,\n          resultSourceMap: 'withKeyArraySelector',\n        }),\n      )\n      .then((res: Any) => {\n        const {result: _result, resultSourceMap} = res as RawQueryResponse<R>\n        const {projectId, dataset} = this.config()\n        const result = stegaEncodeSourceMap(_result, resultSourceMap, this.stegaConfig, {\n          projectId,\n          dataset,\n        })\n        return originalFilterResponse ? result : {...res, result}\n      })\n  }\n}\n","import {vercelStegaSplit} from '@vercel/stega'\n\n/**\n * Can take a `result` JSON from a `const {result} = client.fetch(query, params, {filterResponse: false})`\n * and remove all stega-encoded data from it.\n * @alpha\n */\nexport function vercelStegaCleanAll<Result = unknown>(result: Result): Result {\n  return JSON.parse(\n    JSON.stringify(result, (key, value) => {\n      if (typeof value !== 'string') return value\n      return vercelStegaSplit(value).cleaned\n    }),\n  )\n}\n","export * from '../defineCreateClient'\n\nimport defineCreateClientExports from '../defineCreateClient'\nimport envMiddleware from '../http/browserMiddleware'\nimport {SanityStegaClient} from './SanityStegaClient'\nimport type {ClientStegaConfig} from './types'\n\nconst exp = defineCreateClientExports<SanityStegaClient, ClientStegaConfig>(\n  envMiddleware,\n  SanityStegaClient,\n)\n\nexport * from './shared'\n\n/** @public */\nexport const requester = exp.requester\n\n/** @public */\nexport const createClient = exp.createClient\n"],"names":["defaultStegaConfig","enabled","filter","props","filterDefault","vercelStegaCombineSkip","splitConfig","config","stega","clientConfig","stegaConfig","initStegaConfig","prevConfig","specifiedConfig","Object","assign","newConfig","Error","concat","studioUrl","DRAFTS_PREFIX","getPublishedId","id","startsWith","slice","length","reKeySegment","isKeySegment","segment","test","trim","toString","path","Array","isArray","reduce","target","i","segmentType","separator","_key","from","to","stringify","ESCAPE","UNESCAPE","jsonPath","map","escapedKey","replace","match","_index","join","parseJsonPath","parsed","parseRe","exec","key","m","push","parseInt","jsonPathToStudioPath","JSON","jsonPathToMappingPath","createEditUrl","options","baseUrl","projectId","dataset","workspace","_workspace","tool","_tool","_id","type","endsWith","stringifiedPath","studioPath.toString","searchParams","URLSearchParams","set","segments","routerParams","encodeURIComponent","resolveMapping","resultPath","csm","mappings","resultMappingPath","mapping","matchedPath","pathSuffix","entries","_ref","sort","_ref2","_ref3","key1","key2","substring","resolveStudioBaseRoute","value","isRecord","walkMap","mappingFn","arguments","undefined","v","idx","fromEntries","_ref4","k","encodeIntoResult","result","encoder","resolveMappingResult","source","sourceDocument","documents","document","sourcePath","paths","matchPathSegments","sourcePathSegments","fullSourceSegments","_ref5","endPath","at","some","denylist","has","Set","TRUNCATE_LENGTH","stegaEncodeSourceMap","resultSourceMap","_a","_b","_c","_d","_e","_f","_g","_h","_i","logger","msg","error","call","TypeError","report","encoded","skipped","resultWithStega","_ref6","prettyPathForLogging","_type","_dataset","_projectId","vercelStegaCombine","origin","href","isSkipping","isEncoding","groupCollapsed","log","table","add","values","groupEnd","studioPathToString","_httpRequest","_ObservableSanityStegaClient","ObservableSanityClient","constructor","httpRequest","defaultConfig","__privateAdd","__privateSet","clone","__privateGet","withConfig","fetch","query","params","filterResponse","originalFilterResponse","pipe","res","_result","WeakMap","ObservableSanityStegaClient","_SanityStegaClient","SanityClient","observable","then","SanityStegaClient","vercelStegaCleanAll","parse","vercelStegaSplit","cleaned","exp","defineCreateClientExports","envMiddleware","requester","createClient"],"mappings":"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"}